<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Customizable Water Ripple Effect Website</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-image: linear-gradient(to bottom right, #6dd5ed, #2193b0);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .container {
            text-align: center;
            color: #fff;
        }
        #image-container {
            position: relative;
            display: inline-block;
            border: 5px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        canvas {
            display: block;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        p {
            font-size: 18px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Customizable Water Ripple Effect</h1>
        <div id="image-container">
            <canvas id="canvas"></canvas>
        </div>
        <p>Move your mouse over the image to see the water ripple effect!</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const imageSrc = 'project.png'; // CUSTOMIZE: Replace with your image path
        const image = new Image();
        image.src = imageSrc;

        let width, height;

        // Ripple effect parameters - CUSTOMIZE these to adjust the effect
        const rippleRadius = 20;    // Size of the ripple (increased for larger ripples)
        const damping = 0.95;       // How quickly the ripples lose energy (0-1, higher values = faster fade)
        const decay = 0.95;         // How fast the ripples fade out (0-1, higher values = faster fade)
        const rippleStrength = 2048; // Strength of the ripple effect (increase for more pronounced ripples)
        const offsetX = 0;
        const offsetY = 0;

        let rippleMap = [];
        let lastMap = [];
        let ripple;
        let texture;

        let clickEffectActive = false;
        let clickEffectState = 'none';
        let clickEffectStartTime = 0;
        let heartbeatCount = 0;
        const heartbeatMax = 5;
        const brighteningSize = 0.15; // Increased brightness
        const heartbeatScale = 10; // Larger heartbeat effect

        image.onload = function () {
            width = canvas.width = image.width;
            height = canvas.height = image.height;

            ctx.drawImage(image, 0, 0, width, height);

            texture = ctx.getImageData(0, 0, width, height);
            ripple = ctx.getImageData(0, 0, width, height);

            for (let i = 0; i < width * height; i++) {
                rippleMap[i] = 0;
                lastMap[i] = 0;
            }

            animate();
        };

        function disturb(clientX, clientY) {
            if (clickEffectActive) return;

            const canvasRect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;

            const x = (clientX - canvasRect.left) * scaleX + offsetX;
            const y = (clientY - canvasRect.top) * scaleY + offsetY;

            for (let j = Math.floor(y - rippleRadius); j < Math.floor(y + rippleRadius); j++) {
                for (let k = Math.floor(x - rippleRadius); k < Math.floor(x + rippleRadius); k++) {
                    if (k >= 0 && k < width && j >= 0 && j < height) {
                        const distance = Math.sqrt(Math.pow(k - x, 2) + Math.pow(j - y, 2));
                        if (distance < rippleRadius) {
                            const strength = (1 - distance / rippleRadius) * rippleStrength;
                            rippleMap[j * width + k] += strength;
                        }
                    }
                }
            }
        }

        function renderRipple() {
            let mapIndex = width;
            const _width = width;
            const _height = height;
            const _rippleMap = rippleMap;
            const _lastMap = lastMap;
            const _textureData = texture.data;
            const _rippleData = ripple.data;

            for (let y = 1; y < _height - 1; y++) {
                for (let x = 1; x < _width - 1; x++) {
                    let idx = mapIndex + x;

                    _rippleMap[idx] = (
                        (_lastMap[idx - 1] +
                        _lastMap[idx + 1] +
                        _lastMap[idx - _width] +
                        _lastMap[idx + _width]) * 0.5
                    ) - _rippleMap[idx];
                    _rippleMap[idx] *= damping * decay;

                    let data = _rippleMap[idx];

                    if (data !== 0) {
                        let tx = x + ((_rippleMap[idx - 1] - data) * 0.05);
                        let ty = y + ((_rippleMap[idx - _width] - data) * 0.05);

                        if (tx >= _width) tx = _width - 1;
                        if (tx < 0) tx = 0;
                        if (ty >= _height) ty = _height - 1;
                        if (ty < 0) ty = 0;

                        const pos = ((ty | 0) * _width + (tx | 0)) * 4;
                        const i = idx * 4;

                        _rippleData[i] = _textureData[pos];
                        _rippleData[i + 1] = _textureData[pos + 1];
                        _rippleData[i + 2] = _textureData[pos + 2];
                    }
                }
                mapIndex += _width;
            }

            let temp = lastMap;
            lastMap = rippleMap;
            rippleMap = temp;

            ctx.putImageData(ripple, 0, 0);
        }

        function handleClickEffect() {
            const currentTime = performance.now();
            const elapsedTime = currentTime - clickEffectStartTime;

            const centerX = width / 2;
            const centerY = height / 2;

            if (clickEffectState === 'brightening') {
                const duration = 2500;
                const progress = Math.min(elapsedTime / duration, 1);

                ctx.putImageData(texture, 0, 0);

                ctx.save();
                ctx.globalAlpha = progress * brighteningSize; // Increased brightness
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, width / 6
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 2)'); // Brighter center
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, width / 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();

                if (progress >= 1) {
                    clickEffectState = 'flash';
                    clickEffectStartTime = currentTime;
                }
            } else if (clickEffectState === 'flash') {
                const duration = 200;
                const progress = elapsedTime / duration;

                ctx.putImageData(texture, 0, 0);

                if (progress <= 1) {
                    ctx.save();
                    ctx.globalAlpha = 1 - progress;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, width, height);
                    ctx.restore();
                } else {
                    clickEffectState = 'heartbeat';
                    clickEffectStartTime = currentTime;
                    heartbeatCount = 0;
                }
            } else if (clickEffectState === 'heartbeat') {
                const heartbeatDuration = 1000;
                const timeSinceLastBeat = currentTime - clickEffectStartTime;

                ctx.putImageData(texture, 0, 0);

                const beatProgress = (timeSinceLastBeat % heartbeatDuration) / heartbeatDuration;
                const scale = 1 + 0.05 * Math.sin(beatProgress * 2 * Math.PI) * heartbeatScale;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);

                ctx.globalAlpha = 0.9; // Increased brightness
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, width / 6
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 2)'); // Brighter center
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, width / 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();

                if (timeSinceLastBeat >= heartbeatDuration) {
                    heartbeatCount++;
                    clickEffectStartTime = currentTime;
                }

                if (heartbeatCount >= heartbeatMax) {
                    clickEffectActive = false;
                    clickEffectState = 'none';
                }
            }
        }

        function animate() {
            if (clickEffectActive) {
                handleClickEffect();
            } else {
                renderRipple();
            }
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousemove', function (e) {
            disturb(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousedown', function (e) {
            if (!clickEffectActive) {
                clickEffectActive = true;
                clickEffectState = 'brightening';
                clickEffectStartTime = performance.now();
            }
        });
    </script>
</body>
</html>
